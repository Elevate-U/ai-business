{"version":3,"file":"History-CD87sINY.js","sources":["../../src/pages/History.jsx"],"sourcesContent":["import { h } from 'preact';\nimport './History.css';\nimport Helmet from 'preact-helmet';\nimport { useState, useEffect, useCallback } from 'preact/hooks';\n// Import getWatchHistory instead of getContinueWatching for actual watch history\nimport { getWatchHistoryWithProgress, deleteWatchItem } from '../utils/watchHistory';\nimport { useAuth } from '../context/Auth';\nimport { API_BASE_URL } from '../config';\nimport MovieCard from '../components/MovieCard';\nimport { useStore } from '../store';\n\n// Helper function to fetch with retry logic\nconst fetchWithRetry = async (url, maxRetries = 3, delay = 1000) => {\n    for (let i = 0; i < maxRetries; i++) {\n        try {\n            // Create a timeout promise for environments that don't support AbortSignal.timeout\n            const timeoutPromise = new Promise((_, reject) => {\n                setTimeout(() => reject(new Error('Request timeout')), 10000);\n            });\n\n            const fetchPromise = fetch(url, {\n                headers: {\n                    'Accept': 'application/json',\n                    'Content-Type': 'application/json',\n                }\n            });\n            \n            const response = await Promise.race([fetchPromise, timeoutPromise]);\n            \n            if (!response.ok) {\n                throw new Error(`HTTP ${response.status}: ${response.statusText}`);\n            }\n            \n            return response;\n        } catch (error) {\n            console.warn(`Fetch attempt ${i + 1} failed for ${url}:`, error.message);\n            \n            if (i === maxRetries - 1) {\n                throw error;\n            }\n            \n            // Wait before retrying\n            await new Promise(resolve => setTimeout(resolve, delay * (i + 1)));\n        }\n    }\n};\n\nconst History = () => {\n    const { user } = useAuth();\n    const [history, setHistory] = useState([]);\n    const [loading, setLoading] = useState(true);\n    const [error, setError] = useState(null);\n    const { removeContinueWatchingItem, fetchContinueWatching } = useStore();\n\n    const fetchHistory = useCallback(async () => {\n        if (!user) {\n            setLoading(false);\n            return;\n        }\n        \n        setLoading(true);\n        setError(null);\n        \n        try {\n            // Use the new combined function to fetch history with progress data\n            const historyData = await getWatchHistoryWithProgress(user.id);\n            if (!historyData || historyData.length === 0) {\n                setHistory([]);\n                setLoading(false);\n                return;\n            }\n\n            console.log('ðŸ“š Combined history data received:', {\n                totalItems: historyData.length,\n                itemsWithProgress: historyData.filter(item => item.progress_seconds > 0).length\n            });\n\n            // --- BATCHING LOGIC START ---\n            const batchSize = 10; // Process 10 items at a time\n            let detailedHistory = [];\n\n            for (let i = 0; i < historyData.length; i += batchSize) {\n                const batch = historyData.slice(i, i + batchSize);\n                const batchPromises = batch.map(async (item) => {\n                    try {\n                        // FIX: The media_id is now normalized in the database and does not need to be split.\n                        const numericId = item.media_id; \n                        if (!numericId) {\n                            // This case should ideally not happen if data is clean\n                            console.warn(`Skipping item with invalid media_id: ${item.media_id}`);\n                            return null; // Skip this item\n                        }\n\n                        const response = await fetchWithRetry(`${API_BASE_URL}/tmdb/${item.media_type}/${numericId}`);\n                        const details = await response.json();\n\n                        const result = {\n                            ...details,\n                            id: details.id,\n                            watch_id: `${item.user_id}-${item.media_id}-${item.media_type}-${item.season_number || 0}-${item.episode_number || 0}`,\n                            type: item.media_type,\n                            media_type: item.media_type,\n                            media_id: item.media_id,\n                            season_number: item.season_number,\n                            episode_number: item.episode_number,\n                            watched_at: item.watched_at,\n                            progress_seconds: item.progress_seconds,\n                            duration_seconds: item.duration_seconds\n                        };\n\n                        if (item.media_type === 'tv' && item.season_number && item.episode_number) {\n                            try {\n                                const episodeResponse = await fetchWithRetry(`${API_BASE_URL}/tmdb/tv/${numericId}/season/${item.season_number}/episode/${item.episode_number}`);\n                                const episodeDetails = await episodeResponse.json();\n                                return {\n                                    ...result,\n                                    episode_name: episodeDetails.name,\n                                    still_path: episodeDetails.still_path,\n                                    episode_overview: episodeDetails.overview\n                                };\n                            } catch (episodeError) {\n                                console.error(`Error fetching episode details for ${numericId}:`, episodeError);\n                                // Return the main result even if episode details fail\n                                return result;\n                            }\n                        }\n\n                        return result;\n                    } catch (error) {\n                        console.error(`Error fetching details for ${item.media_type} ${item.media_id}:`, error);\n                        return {\n                            id: item.media_id,\n                            watch_id: `${item.user_id}-${item.media_id}-${item.media_type}-${item.season_number || 0}-${item.episode_number || 0}`,\n                            type: item.media_type,\n                            media_type: item.media_type,\n                            media_id: item.media_id,\n                            season_number: item.season_number,\n                            episode_number: item.episode_number,\n                            watched_at: item.watched_at,\n                            title: item.media_type === 'tv' ? 'Unknown TV Show' : 'Unknown Movie',\n                            name: item.media_type === 'tv' ? 'Unknown TV Show' : undefined,\n                            poster_path: null,\n                            overview: 'Details could not be loaded.',\n                            _failed_to_load: true,\n                            progress_seconds: item.progress_seconds,\n                            duration_seconds: item.duration_seconds\n                        };\n                    }\n                });\n\n                const batchResults = await Promise.allSettled(batchPromises);\n                detailedHistory = detailedHistory.concat(batchResults);\n                \n                // Optional: Update state after each batch to show progress\n                const successfulResults = detailedHistory\n                    .filter(result => result.status === 'fulfilled' && result.value)\n                    .map(result => result.value);\n                setHistory(successfulResults);\n            }\n            // --- BATCHING LOGIC END ---\n\n            // Final state update with all results\n            const finalSuccessfulResults = detailedHistory\n                .filter(result => result.status === 'fulfilled' && result.value)\n                .map(result => result.value);\n            \n            setHistory(finalSuccessfulResults);\n        } catch (error) {\n            console.error('Error fetching watch history:', error);\n            setError('Failed to load watch history. Please try again.');\n            setHistory([]);\n        } finally {\n            setLoading(false);\n        }\n    }, [user]);\n\n    useEffect(() => {\n        fetchHistory();\n    }, [fetchHistory, user]);\n\n    const handleDelete = async (itemToDelete) => {\n        // Optimistically remove the item from the UI using the unique watch_id\n        setHistory(history.filter(item => item.watch_id !== itemToDelete.watch_id));\n        \n        // Optimistically remove from the global \"Continue Watching\" state\n        removeContinueWatchingItem(itemToDelete.media_id);\n\n        try {\n            // Call the delete function from the utils\n            await deleteWatchItem(user.id, itemToDelete);\n\n            // Refetch continue watching to ensure it's up to date\n            await fetchContinueWatching(user.id);\n        } catch (error) {\n            console.error(\"Failed to delete item or refetch continue watching:\", error);\n            // Optionally, add the item back to the history list on failure\n            // and show a toast notification to the user.\n            // For now, we'll just log the error.\n        }\n    };\n\n    const handleRetry = () => {\n        fetchHistory();\n    };\n\n    if (loading) {\n        return <div class=\"container\"><p>Loading watch history...</p></div>;\n    }\n\n    if (error) {\n        return (\n            <div class=\"container\">\n                <Helmet>\n                    <title>Watch History - Fylm</title>\n                </Helmet>\n                <h1>Watch History</h1>\n                <div class=\"error-message\">\n                    <p>{error}</p>\n                    <button onClick={handleRetry} class=\"retry-button\">Retry</button>\n                </div>\n            </div>\n        );\n    }\n\n    return (\n        <div class=\"container\">\n            <Helmet>\n                <title>Watch History - Fylm</title>\n            </Helmet>\n            <h1>Watch History</h1>\n            {history.length > 0 ? (\n                <div class=\"movie-grid\">\n                    {history.map(item => {\n                        return (\n                            <MovieCard \n                                key={item.watch_id} \n                                item={item} \n                                type={item.type}\n                                progress={item.progress_seconds}\n                                duration={item.duration_seconds}\n                                showDeleteButton={true}\n                                onDelete={handleDelete}\n                            />\n                        );\n                    })}\n                </div>\n            ) : (\n                <p>Your watch history is empty.</p>\n            )}\n        </div>\n    );\n};\n\nexport default History; "],"names":["fetchWithRetry","url","maxRetries","delay","timeoutPromise","_","reject","fetchPromise","response","error","resolve","History","user","useAuth","history","setHistory","useState","loading","setLoading","setError","removeContinueWatchingItem","fetchContinueWatching","useStore","fetchHistory","useCallback","historyData","getWatchHistoryWithProgress","item","batchSize","detailedHistory","i","batchPromises","numericId","details","API_BASE_URL","result","episodeDetails","episodeError","batchResults","successfulResults","finalSuccessfulResults","useEffect","handleDelete","itemToDelete","deleteWatchItem","handleRetry","jsx","jsxs","Helmet","MovieCard"],"mappings":"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"}